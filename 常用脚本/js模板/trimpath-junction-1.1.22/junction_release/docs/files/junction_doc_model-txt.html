<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><title>web-MVC Model</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script></head><body class=UnframedPage onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.35 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<table border=0 cellspacing=0 cellpadding=0 width=100%><tr><td class=MenuSection valign=top><!--START_ND_MENU--><div class=MEntry><div class=MFile><a href="junction_doc_about-txt.html">About TrimPath Junction</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run-txt.html">Runtime Environments</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_browser-txt.html">Runtime In The Browser</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_server-txt.html">Runtime On The Server</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_sync-txt.html">Synchronization</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_translation-txt.html">Translations</a></div></div><div class=MEntry><div class=MFile><a href="junction-js.html">TrimPath.<span class=HB> </span>junction</a></div></div><div class=MEntry><div class=MFile><a href="junctionClient-js.html">TrimPath.<span class=HB> </span>junctionClient</a></div></div><div class=MEntry><div class=MFile><a href="junctionHelpers-js.html">TrimPath.<span class=HB> </span>junctionHelpers</a></div></div><div class=MEntry><div class=MFile><a href="junctionUtil-js.html">TrimPath.<span class=HB> </span>junctionUtil</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_controller-txt.html">web-MVC Controller</a></div></div><div class=MEntry><div class=MFile id=MSelected>web-MVC Model</div></div><div class=MEntry><div class=MFile><a href="junction_doc_view-txt.html">web-MVC View</a></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Index</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MIndex><a href="../index/General.html">Everything</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Variables.html">Variables</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Properties.html">Properties</a></div></div></div></div></div><!--END_ND_MENU--></td>

<td class=ContentSection valign=top><div class=CGeneric id=MainTopic><div class=CTopic><h1 class=CTitle><a name="web-MVC_Model"></a>web-MVC Model</h1><div class=CBody><p class=CParagraph>The Model in the web Model-View-Controller (web-MVC) design provides object-relational access to data stored in a relational database management system (RDBMS).&nbsp; The Active Record pattern of object-relationsal mapping is followed, where each database table is mapped to one JavaScript Model class.</p><p class=CParagraph>On the JavaScript side, a Model is just a JavaScript function (sometimes called constructor function).</p><p class=CParagraph>Each Model is contained in its own separate file, under the /app/models/[modelName].js naming pattern.&nbsp;  For example, /app/models/invoice.js might contain...</p><blockquote><pre class=CCode>Invoice = function() {}<br><br>modelInit('Invoice');<br><br>Invoice.belongs_to('Customer');<br>Invoice.belongs_to('SalesRep');<br>Invoice.has_many('InvoiceLines');</pre></blockquote><h4 class=CHeading>Naming Conventions</h4><p class=CParagraph>By convention, the name of a Model function is capitalized and singular.&nbsp; For example, Invoice and InvoiceLine.&nbsp;  By convention, the name of a Model is the same as its corresponding database table name.</p><p class=CParagraph>The corresponding code files for a Model are not capitalized.&nbsp;  For example /app/models/invoice.js and /app/models/invoiceLine.js.</p><p class=CParagraph>Programmers should use the global variable programming idiom as show above, rather than private variable idiom, so that the Junction system can easily reload code automatically as it&rsquo;s changed.&nbsp;  Otherwise, development will be horribly unproductive, preventing a quick edit-refreshPage-view-debug cycle.</p><p class=CParagraph>For example, use the following coding style when defining a Model function/constructor...</p><blockquote><pre class=CCode>InvoiceLine = function() {} // Correct.</pre></blockquote><p class=CParagraph>instead of...</p><blockquote><pre class=CCode>function InvoiceLine() {} // Wrong, won't reload automatically.</pre></blockquote><p class=CParagraph>and instead of...</p><blockquote><pre class=CCode>var InvoiceLine = function() {} // Wrong, won't reload automatically.</pre></blockquote><h4 class=CHeading>Class Methods</h4><p class=CParagraph>Class methods, also known as class static methods, can be defined on the Model function as easily.&nbsp;  For example...</p><blockquote><pre class=CCode>Invoice = function() {}<br><br>modelInit('Invoice');<br><br>Invoice.findByCustomer = function(customerId) {<br>    return Invoice.findActive('all', {<br>        conditions: [ 'Invoice.customer_id = ?', customerId ] });<br>}<br><br>// Now, you can call...<br>// var invoices = Invoice.findByCustomer(123);</pre></blockquote><h4 class=CHeading>Instance Methods</h4><p class=CParagraph>Instance methods are defined by using the prototype feature of the JavaScript language.&nbsp;  For example..</p><blockquote><pre class=CCode>Invoice = function() {}<br><br>Invoice.prototype.markAsClosed = function() {<br>    if (this.status == 'closed')<br>        throw new Error('Invoice already closed: ' + this.id);<br>    this.status = 'closed';<br>}<br><br>// Now, on an Invoice instance, you can call...<br>// invoice.markAsClosed();</pre></blockquote><p class=CParagraph>Alternatively, if you want to use a private-variable-friendly idiom for defining Model methods, you can...</p><blockquote><pre class=CCode>Invoice = function() {<br>  // Inside the constructor function, we can define private variables...<br><br>  var self = this;                    // A private, transient instance var.<br>  var invoiceSecretEncryptKey = null; // A private, transient instance var.<br><br>  // The above are transient, not-persistent.<br><br>  this.setSEKey = function(key) {<br>      invoiceSecretEncrypKey = key;<br>  }<br><br>  this.signAndApprove = function() {<br>    this.signed = true;<br>    this.signature = encrypt(invoiceSecretEncryptKey, ...);<br>    this.status = 'approved';<br>  }<br>}</pre></blockquote><h4 class=CHeading>Metadata and modelInit</h4><p class=CParagraph>In the top code example, you may have seen the call to the modelInit() function.&nbsp; The modelInit() function decorates a function/constructor with class methods and instance methods that turn the function/constructor into an actual Model class.</p><blockquote><pre class=CCode>Invoice = function() {}<br><br>modelInit('Invoice');<br>modelInit('Invoice');<br>modelInit('Invoice'); // The modelInit() call is idempotent.<br><br>// Now, you can call the extra class methods on Invoice.<br>// e.g., var invoices = Invoice.find('all');</pre></blockquote><p class=CParagraph>After calling modelInit(), you can now use Model function class methods to describe useful information about your Model to the Junction system.&nbsp; For example...</p><blockquote><pre class=CCode>Invoice = function() {}<br><br>modelInit('Invoice');<br><br>Invoice.belongsTo('Customer');<br>Invoice.belongsTo('SalesRep');<br>Invoice.hasMany('InvoiceLines');</pre></blockquote><p class=CParagraph>The calls made above on the Model function, such as belongsTo() and hasMany(), decorate the Model with even more class methods and instance methods.&nbsp; For example, you can declare Model to Model relationships and field/column validations using these decoration methods.&nbsp; Please see the modelInit() API reference documentation for more information on these Model metadata decorations.</p><h4 class=CHeading>Creating Model Instances</h4><p class=CParagraph>Model instances are created by using the Model.newInstance() method, rather than directly using JavaScript&rsquo;s new operator.&nbsp;  For example...</p><blockquote><pre class=CCode>var invoice = Invoice.newInstance();<br>// invoice.created_at != null;<br><br>var invoiceWrong = new Invoice();<br>// invoice.created_at == null;</pre></blockquote><h4 class=CHeading>Model Fields/Columns</h4><p class=CParagraph>By convention, column names, or Model field/property names, are lowercase, using underscore (&lsquo;_&rsquo;) characters to separate words.&nbsp; For example, parent_folder_id, created_at, updated_at, title.</p><h4 class=CHeading>Migrations</h4><p class=CParagraph>In the Junction system, the way to create database tables and modify the database schema over time (adding columns, adding more tables) is called migrations.&nbsp; Each migration is stored as a separate script file under the code/db/migrate directory.&nbsp;  A migration file follows a naming convention of NNNNN_some_description.js.&nbsp;  For example...</p><blockquote><pre class=CCode>code/<br>  db/<br>    migrate/<br>      0001_initial_schema.js<br>      0002_add_internationalization.js<br>      0003_add_promotions_coupons.js<br>      0004_tagging.js</pre></blockquote><p class=CParagraph>The Junction system will apply the above scripts in sorted order during a database migration.&nbsp;  In the above example, that would bring the database schema to version 4.&nbsp;  Database migrations are automatically applied by the Junction system to the client and server-side RDBMS.</p><p class=CParagraph>Each migration file can use a simple declarative, JSON-like syntax (called &lsquo;def&rsquo;) to add new database tables, columns, and indexes.&nbsp;  For example...</p><blockquote><pre class=CCode>{ def: [<br>    [ 'standard_table', 'Task',<br>      [ 'name',         'varchar(100)' ],<br>      [ 'notes',        'varchar(4000)' ],<br>      [ 'project_id',   'integer' ],<br>      [ 'completed_at', 'datetime' ] ],<br>    [ 'standard_table', 'Project',<br>      [ 'name',         'varchar(100)' ],<br>      [ 'notes',        'varchar(4000)' ],<br>      [ 'due_at',       'datetime' ],<br>      [ 'completed_at', 'datetime' ],<br>      [ 'color',        'varchar(100)' ] ]<br>  ]<br>}</pre></blockquote><p class=CParagraph>Each migration file may also define optional &lsquo;up&rsquo; and &lsquo;down&rsquo; functions, which can be used in addition to or in-lieu of the &lsquo;def&rsquo; declarative syntax.&nbsp; For example, the previous def example is equivalent to the following up() and down() functions which explicitly call the DDL methods...</p><blockquote><pre class=CCode>{ up: function() {<br>    createStandardTable('Task',<br>      column('name',         'varchar(100)'),<br>      column('notes',        'varchar(4000)'),<br>      column('project_id',   'integer'),<br>      column('completed_at', 'datetime')<br>    );<br>    createStandardTable('Project',<br>      column('name',         'varchar(100)'),<br>      column('notes',        'varchar(4000)'),<br>      column('due_at',       'datetime'),<br>      column('completed_at', 'datetime'),<br>      column('color',        'varchar(100)')<br>    );<br>  },<br>  down: function() {<br>    dropTable('Task');<br>    dropTable('Project');<br>  }<br>}</pre></blockquote><p class=CParagraph>In the above script, the up function creates two tables, Task and Project.&nbsp; The down function drops those two tables, providing a reverse or undo of the up function.</p><p class=CParagraph>The above script uses the createStandardTable() function, which creates additional synchronization tracking columns on the Task and Project tables.&nbsp;  So, Task and Project records will be synchronized by Junction between server and client RDBMS.</p><p class=CParagraph>When the Junction system invokes the up and down functions of a migration step, the Junction system may not be fully loaded yet.&nbsp; So, while it&rsquo;s safe to call createStandardTable()/dropTable() and other migration API functions from your up/down functions, calling other Junction API functions may not work.&nbsp;  For example, calling Task.find() during the up or down function will probably fail, because the Task Model probably has not been initialized yet.&nbsp; However, calling TrimPath.junction.dbExecute(), which is a lower-level function, to invoke straight SQL is allowed during your up/down functions.</p></div></div></div>

</td>

</tr></table><div class=Footer><!--START_ND_FOOTER-->Generated by <a href="http://www.naturaldocs.org">Natural Docs</a><!--END_ND_FOOTER--></div>
<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>